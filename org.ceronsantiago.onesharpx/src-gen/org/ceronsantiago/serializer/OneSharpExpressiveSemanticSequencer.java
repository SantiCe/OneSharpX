/*
 * generated by Xtext
 */
package org.ceronsantiago.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.ceronsantiago.oneSharpExpressive.Call;
import org.ceronsantiago.oneSharpExpressive.Command;
import org.ceronsantiago.oneSharpExpressive.FunctionDeclaration;
import org.ceronsantiago.oneSharpExpressive.FunctionHeader;
import org.ceronsantiago.oneSharpExpressive.Goto;
import org.ceronsantiago.oneSharpExpressive.LoopCase;
import org.ceronsantiago.oneSharpExpressive.NormalCase;
import org.ceronsantiago.oneSharpExpressive.OneSharpExpressivePackage;
import org.ceronsantiago.oneSharpExpressive.Program;
import org.ceronsantiago.oneSharpExpressive.Write;
import org.ceronsantiago.services.OneSharpExpressiveGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class OneSharpExpressiveSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private OneSharpExpressiveGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == OneSharpExpressivePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case OneSharpExpressivePackage.CALL:
				sequence_Call(context, (Call) semanticObject); 
				return; 
			case OneSharpExpressivePackage.COMMAND:
				sequence_Command(context, (Command) semanticObject); 
				return; 
			case OneSharpExpressivePackage.FUNCTION_DECLARATION:
				sequence_FunctionDeclaration(context, (FunctionDeclaration) semanticObject); 
				return; 
			case OneSharpExpressivePackage.FUNCTION_HEADER:
				sequence_FunctionHeader(context, (FunctionHeader) semanticObject); 
				return; 
			case OneSharpExpressivePackage.GOTO:
				sequence_Goto(context, (Goto) semanticObject); 
				return; 
			case OneSharpExpressivePackage.LOOP_CASE:
				sequence_LoopCase(context, (LoopCase) semanticObject); 
				return; 
			case OneSharpExpressivePackage.NORMAL_CASE:
				sequence_NormalCase(context, (NormalCase) semanticObject); 
				return; 
			case OneSharpExpressivePackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case OneSharpExpressivePackage.WRITE:
				sequence_Write(context, (Write) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     function=ID
	 */
	protected void sequence_Call(EObject context, Call semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, OneSharpExpressivePackage.Literals.CALL__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OneSharpExpressivePackage.Literals.CALL__FUNCTION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCallAccess().getFunctionIDTerminalRuleCall_2_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (label=ID? (command=Write | command=NormalCase | command=LoopCase | command=Goto | command=Call))
	 */
	protected void sequence_Command(EObject context, Command semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (funcHeader=FunctionHeader commands+=Command+)
	 */
	protected void sequence_FunctionDeclaration(EObject context, FunctionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     funcName=ID
	 */
	protected void sequence_FunctionHeader(EObject context, FunctionHeader semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, OneSharpExpressivePackage.Literals.FUNCTION_HEADER__FUNC_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OneSharpExpressivePackage.Literals.FUNCTION_HEADER__FUNC_NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFunctionHeaderAccess().getFuncNameIDTerminalRuleCall_0_0(), semanticObject.getFuncName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     label=ID
	 */
	protected void sequence_Goto(EObject context, Goto semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, OneSharpExpressivePackage.Literals.GOTO__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OneSharpExpressivePackage.Literals.GOTO__LABEL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getGotoAccess().getLabelIDTerminalRuleCall_2_0(), semanticObject.getLabel());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (register=VAR_INT caseOne+=Command* caseSharp+=Command* caseEmpty+=Command*)
	 */
	protected void sequence_LoopCase(EObject context, LoopCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (register=VAR_INT caseOne+=Command* caseSharp+=Command* caseEmpty+=Command*)
	 */
	protected void sequence_NormalCase(EObject context, NormalCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     functions+=FunctionDeclaration+
	 */
	protected void sequence_Program(EObject context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (word=OS register=VAR_INT)
	 */
	protected void sequence_Write(EObject context, Write semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, OneSharpExpressivePackage.Literals.WRITE__WORD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OneSharpExpressivePackage.Literals.WRITE__WORD));
			if(transientValues.isValueTransient(semanticObject, OneSharpExpressivePackage.Literals.WRITE__REGISTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OneSharpExpressivePackage.Literals.WRITE__REGISTER));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWriteAccess().getWordOSTerminalRuleCall_2_0(), semanticObject.getWord());
		feeder.accept(grammarAccess.getWriteAccess().getRegisterVAR_INTParserRuleCall_3_0(), semanticObject.getRegister());
		feeder.finish();
	}
}
