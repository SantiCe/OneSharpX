/**
 * generated by Xtext 2.9.0
 */
package ceronsantiago.validation;

import ceronsantiago.oneSharpExpressive.Call;
import ceronsantiago.oneSharpExpressive.CallParam;
import ceronsantiago.oneSharpExpressive.Command;
import ceronsantiago.oneSharpExpressive.CommandBlock;
import ceronsantiago.oneSharpExpressive.FunctionDeclaration;
import ceronsantiago.oneSharpExpressive.IntParamDec;
import ceronsantiago.oneSharpExpressive.NormalCase;
import ceronsantiago.oneSharpExpressive.OneSharpExpressivePackage;
import ceronsantiago.oneSharpExpressive.ParamDec;
import ceronsantiago.oneSharpExpressive.Program;
import ceronsantiago.oneSharpExpressive.UnlabeledCommand;
import ceronsantiago.utils.Utils;
import ceronsantiago.validation.AbstractOneSharpExpressiveValidator;
import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class OneSharpExpressiveValidator extends AbstractOneSharpExpressiveValidator {
  /**
   * Checks that there are no repeated labels within the same CommandBlock
   */
  @Check
  public void checkNoRepeatedLabels(final Command command) {
    String _name = command.getName();
    boolean _equals = Objects.equal(_name, null);
    if (_equals) {
      return;
    }
    String name = command.getName();
    CommandBlock _commandBlock = Utils.getCommandBlock(command);
    EList<Command> _commands = _commandBlock.getCommands();
    final Function1<Command, Boolean> _function = (Command cmd) -> {
      boolean _and = false;
      String _name_1 = cmd.getName();
      boolean _notEquals = (!Objects.equal(_name_1, null));
      if (!_notEquals) {
        _and = false;
      } else {
        boolean _notEquals_1 = (!Objects.equal(cmd, command));
        _and = _notEquals_1;
      }
      return Boolean.valueOf(_and);
    };
    Iterable<Command> _filter = IterableExtensions.<Command>filter(_commands, _function);
    for (final Command cmd : _filter) {
      String _name_1 = cmd.getName();
      boolean _equals_1 = name.equals(_name_1);
      if (_equals_1) {
        this.error((("The label " + name) + " is repeated within the same block"), command, OneSharpExpressivePackage.Literals.COMMAND__NAME, "Invalid label");
        this.error((("The label " + name) + " is repeated within the same block"), cmd, OneSharpExpressivePackage.Literals.COMMAND__NAME, "Invalid label");
      }
    }
  }
  
  /**
   * Checks that there are no repeated name parameters in a function declaration.
   */
  @Check
  public void checkNoRepeatedParamNamesInFunctionDeclaration(final ParamDec pdec) {
    FunctionDeclaration fdec = Utils.getFunctionDeclaration(pdec);
    final String name = pdec.getName();
    EList<ParamDec> _params = fdec.getParams();
    final Function1<ParamDec, Boolean> _function = (ParamDec param) -> {
      boolean _and = false;
      boolean _notEquals = (!Objects.equal(param, pdec));
      if (!_notEquals) {
        _and = false;
      } else {
        String _name = param.getName();
        boolean _equals = _name.equals(name);
        _and = _equals;
      }
      return Boolean.valueOf(_and);
    };
    Iterable<ParamDec> _filter = IterableExtensions.<ParamDec>filter(_params, _function);
    for (final ParamDec param : _filter) {
      {
        this.error((("There are two parameters with the name " + name) + "."), param, OneSharpExpressivePackage.Literals.PARAM_DEC__NAME, "Invalid name");
        this.error((("There are two parameters with the name " + name) + "."), pdec, OneSharpExpressivePackage.Literals.PARAM_DEC__NAME, "Invalid name");
      }
    }
  }
  
  /**
   * Checks that parameter usage is correct in terms of number of parameters and types.
   */
  @Check
  public void checkCorrectNumberOfParams(final Call cmd) {
    FunctionDeclaration fdec = cmd.getFunction();
    EList<ParamDec> _params = fdec.getParams();
    int _size = _params.size();
    EList<CallParam> _params_1 = cmd.getParams();
    int _size_1 = _params_1.size();
    boolean _notEquals = (_size != _size_1);
    if (_notEquals) {
      EList<ParamDec> _params_2 = fdec.getParams();
      int _size_2 = _params_2.size();
      String _plus = ("Incorrect number of parameters. Expected: " + Integer.valueOf(_size_2));
      String _plus_1 = (_plus + " Actual: ");
      EList<CallParam> _params_3 = cmd.getParams();
      int _size_3 = _params_3.size();
      String _plus_2 = (_plus_1 + Integer.valueOf(_size_3));
      String _plus_3 = (_plus_2 + ".");
      this.error(_plus_3, cmd, OneSharpExpressivePackage.Literals.CALL__PARAMS, "Invalid parameters");
    }
  }
  
  /**
   * Check for correct type of parameters used in FunctionCalls.
   */
  @Check
  public void checkCorrectTypeOfParams(final CallParam param) {
    EObject container = ((EObject) param);
    while (((!Objects.equal(container, null)) && (!(container instanceof Call)))) {
      EObject _eContainer = container.eContainer();
      container = _eContainer;
    }
    boolean _equals = Objects.equal(container, null);
    if (_equals) {
      return;
    }
    Call command = ((Call) container);
    EList<CallParam> callparams = command.getParams();
    FunctionDeclaration _function = command.getFunction();
    EList<ParamDec> funparams = _function.getParams();
    int pos = 0;
    boolean found = false;
    for (; ((pos < callparams.size()) && (!found)); pos++) {
      CallParam _get = callparams.get(pos);
      boolean _equals_1 = Objects.equal(_get, param);
      if (_equals_1) {
        found = true;
      }
    }
    pos--;
    if ((!found)) {
      return;
    }
    int _size = funparams.size();
    boolean _greaterEqualsThan = (pos >= _size);
    if (_greaterEqualsThan) {
      this.checkCorrectNumberOfParams(command);
    } else {
      ParamDec pdec = funparams.get(pos);
      boolean _and = false;
      if (!(pdec instanceof IntParamDec)) {
        _and = false;
      } else {
        boolean _matchesType = Utils.matchesType(param, pdec);
        boolean _not = (!_matchesType);
        _and = _not;
      }
      if (_and) {
        this.error("Incorrect type of parameter. Expected INT and found STRING.", param, OneSharpExpressivePackage.Literals.CALL_PARAM__PARAM);
      } else {
        boolean _matchesType_1 = Utils.matchesType(param, pdec);
        boolean _not_1 = (!_matchesType_1);
        if (_not_1) {
          this.error("Incorrect type of parameter. Expected STRING and found INT.", param, OneSharpExpressivePackage.Literals.CALL_PARAM__PARAM);
        }
      }
    }
  }
  
  private String paramVal(final CallParam param) {
    String _stringVal = param.getStringVal();
    boolean _notEquals = (!Objects.equal(_stringVal, null));
    if (_notEquals) {
      return param.getStringVal();
    }
    ParamDec _param = param.getParam();
    boolean _notEquals_1 = (!Objects.equal(_param, null));
    if (_notEquals_1) {
      ParamDec _param_1 = param.getParam();
      return _param_1.getName();
    }
    int _intVal = param.getIntVal();
    return (Integer.valueOf(_intVal) + "");
  }
  
  /**
   * Function names should be unique.
   */
  @Check
  public void checkUniqueFnName(final FunctionDeclaration fdec) {
    String name = fdec.getName();
    EObject _eContainer = fdec.eContainer();
    Program program = ((Program) _eContainer);
    EList<FunctionDeclaration> _functions = program.getFunctions();
    final Function1<FunctionDeclaration, Boolean> _function = (FunctionDeclaration f) -> {
      return Boolean.valueOf((!Objects.equal(f, fdec)));
    };
    Iterable<FunctionDeclaration> _filter = IterableExtensions.<FunctionDeclaration>filter(_functions, _function);
    for (final FunctionDeclaration fn : _filter) {
      String _name = fn.getName();
      boolean _equals = Objects.equal(name, _name);
      if (_equals) {
        this.error((("Different functions must have different names. Two functions with name: " + name) + "."), fdec, OneSharpExpressivePackage.Literals.FUNCTION_DECLARATION__NAME);
        this.error((("Different functions must have different names. Two functions with name: " + name) + "."), fn, OneSharpExpressivePackage.Literals.FUNCTION_DECLARATION__NAME);
      }
    }
  }
  
  /**
   * Check that there are no cyclic/recursive calls.
   */
  @Check
  public void checkForNoCyclicCalls(final Call command) {
    HashSet<String> gray = new HashSet<String>();
    HashSet<String> black = new HashSet<String>();
    FunctionDeclaration _function = command.getFunction();
    boolean _dfs = this.dfs(_function, gray, black);
    boolean _not = (!_dfs);
    if (_not) {
      FunctionDeclaration _function_1 = command.getFunction();
      String _name = _function_1.getName();
      String _plus = ("Cyclic call detected. " + _name);
      this.error(_plus, command, OneSharpExpressivePackage.Literals.CALL__FUNCTION, "Cycle detected");
    }
  }
  
  private boolean dfs(final FunctionDeclaration fdec, final HashSet<String> gray, final HashSet<String> black) {
    String _name = fdec.getName();
    boolean _contains = gray.contains(_name);
    if (_contains) {
      return false;
    }
    String _name_1 = fdec.getName();
    gray.add(_name_1);
    ArrayList<FunctionDeclaration> _arrayList = new ArrayList<FunctionDeclaration>();
    List<FunctionDeclaration> list = ((List<FunctionDeclaration>) _arrayList);
    CommandBlock _body = fdec.getBody();
    List<FunctionDeclaration> _functionsCalled = this.functionsCalled(_body, list);
    list = _functionsCalled;
    final Function1<FunctionDeclaration, Boolean> _function = (FunctionDeclaration f) -> {
      String _name_2 = f.getName();
      boolean _contains_1 = black.contains(_name_2);
      return Boolean.valueOf((!_contains_1));
    };
    Iterable<FunctionDeclaration> _filter = IterableExtensions.<FunctionDeclaration>filter(list, _function);
    for (final FunctionDeclaration fn : _filter) {
      boolean _dfs = this.dfs(fn, gray, black);
      boolean _not = (!_dfs);
      if (_not) {
        return false;
      }
    }
    String _name_2 = fdec.getName();
    gray.remove(_name_2);
    String _name_3 = fdec.getName();
    black.add(_name_3);
    return true;
  }
  
  private List<FunctionDeclaration> functionsCalled(final CommandBlock block, final List<FunctionDeclaration> list) {
    EList<Command> _commands = block.getCommands();
    final Function1<Command, Boolean> _function = (Command cmd) -> {
      UnlabeledCommand _command = cmd.getCommand();
      return Boolean.valueOf((_command instanceof Call));
    };
    Iterable<Command> _filter = IterableExtensions.<Command>filter(_commands, _function);
    final Function1<Command, FunctionDeclaration> _function_1 = (Command cmd) -> {
      UnlabeledCommand _command = cmd.getCommand();
      return ((Call) _command).getFunction();
    };
    Iterable<FunctionDeclaration> _map = IterableExtensions.<Command, FunctionDeclaration>map(_filter, _function_1);
    List<FunctionDeclaration> _list = IterableExtensions.<FunctionDeclaration>toList(_map);
    list.addAll(_list);
    List<FunctionDeclaration> retList = list;
    EList<Command> _commands_1 = block.getCommands();
    final Function1<Command, Boolean> _function_2 = (Command cmd) -> {
      UnlabeledCommand _command = cmd.getCommand();
      return Boolean.valueOf((_command instanceof NormalCase));
    };
    Iterable<Command> _filter_1 = IterableExtensions.<Command>filter(_commands_1, _function_2);
    final Function1<Command, NormalCase> _function_3 = (Command cmd) -> {
      UnlabeledCommand _command = cmd.getCommand();
      return ((NormalCase) _command);
    };
    Iterable<NormalCase> _map_1 = IterableExtensions.<Command, NormalCase>map(_filter_1, _function_3);
    for (final NormalCase cas : _map_1) {
      {
        CommandBlock _caseOne = cas.getCaseOne();
        List<FunctionDeclaration> _functionsCalled = this.functionsCalled(_caseOne, retList);
        retList = _functionsCalled;
        CommandBlock _caseEmpty = cas.getCaseEmpty();
        List<FunctionDeclaration> _functionsCalled_1 = this.functionsCalled(_caseEmpty, retList);
        retList = _functionsCalled_1;
        CommandBlock _caseSharp = cas.getCaseSharp();
        List<FunctionDeclaration> _functionsCalled_2 = this.functionsCalled(_caseSharp, retList);
        retList = _functionsCalled_2;
      }
    }
    return retList;
  }
}
