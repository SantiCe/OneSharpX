/**
 * generated by Xtext 2.9.0
 */
package ceronsantiago.generator;

import ceronsantiago.oneSharpExpressive.Call;
import ceronsantiago.oneSharpExpressive.CallParam;
import ceronsantiago.oneSharpExpressive.Command;
import ceronsantiago.oneSharpExpressive.CommandBlock;
import ceronsantiago.oneSharpExpressive.FunctionDeclaration;
import ceronsantiago.oneSharpExpressive.Goto;
import ceronsantiago.oneSharpExpressive.IntParamDec;
import ceronsantiago.oneSharpExpressive.NormalCase;
import ceronsantiago.oneSharpExpressive.ParamDec;
import ceronsantiago.oneSharpExpressive.Program;
import ceronsantiago.oneSharpExpressive.RegisterParam;
import ceronsantiago.oneSharpExpressive.UnlabeledCommand;
import ceronsantiago.oneSharpExpressive.WordParam;
import ceronsantiago.oneSharpExpressive.Write;
import ceronsantiago.utils.LabelContext;
import ceronsantiago.utils.ParameterContext;
import ceronsantiago.utils.Utils;
import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Set;
import java.util.Stack;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * Generates code from your model files on save.
 */
@SuppressWarnings("all")
public class OneSharpExpressiveGenerator extends AbstractGenerator {
  private final static String SEP = "\n";
  
  private final static String TAB = "\t";
  
  private LabelContext currentLabelContext;
  
  private HashMap<Integer, LabelContext> labelContexts;
  
  /**
   * TODO: THIS IS MACHETE, for now lets leave it but it will cause failures.
   */
  private int projectedSize = 0;
  
  private ArrayList<String> commandArray;
  
  private ArrayList<String> midLangArray;
  
  private Stack<ParameterContext> parameterContextStack;
  
  /**
   * Map that for a function tells how many lines it will take. Implemented to make counting a bit more efficient.
   */
  private HashMap<String, Integer> functionLength;
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    try {
      URI _uRI = resource.getURI();
      String _lastSegment = _uRI.lastSegment();
      String filename = _lastSegment.replace(".osx", "");
      this.projectedSize = 0;
      EList<EObject> _contents = resource.getContents();
      EObject _get = _contents.get(0);
      final Program program = ((Program) _get);
      HashMap<String, Integer> _hashMap = new HashMap<String, Integer>();
      this.functionLength = _hashMap;
      CommandBlock _body = program.getBody();
      EList<Command> _commands = _body.getCommands();
      for (final Command cmd : _commands) {
        UnlabeledCommand _command = cmd.getCommand();
        this.calculateSize(_command);
      }
      ArrayList<String> _arrayList = new ArrayList<String>();
      this.commandArray = _arrayList;
      ArrayList<String> _newArrayList = CollectionLiterals.<String>newArrayList();
      this.midLangArray = _newArrayList;
      int _projectedSize = this.projectedSize;
      this.projectedSize = (_projectedSize + 10);
      ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, this.projectedSize, true);
      for (final Integer i : _doubleDotLessThan) {
        {
          this.commandArray.add("");
          this.midLangArray.add("");
        }
      }
      HashMap<Integer, LabelContext> _hashMap_1 = new HashMap<Integer, LabelContext>();
      this.labelContexts = _hashMap_1;
      Stack<ParameterContext> _stack = new Stack<ParameterContext>();
      this.parameterContextStack = _stack;
      this.currentLabelContext = null;
      CommandBlock _body_1 = program.getBody();
      int fin = this.resolveCommandBlock(_body_1, 0);
      final Function1<String, Integer> _function = (String s) -> {
        return Integer.valueOf(s.length());
      };
      String _maxBy = IterableExtensions.<String, Integer>maxBy(this.commandArray, _function);
      int _length = _maxBy.length();
      int _max = Math.max(fin, _length);
      int _plus = (_max + 5);
      this.projectedSize = _plus;
      Collection<LabelContext> _values = this.labelContexts.values();
      for (final LabelContext container : _values) {
        for (final Integer index : container.gotosToSolve) {
          {
            String label = this.commandArray.get((index).intValue());
            int targetIn = container.resolve(label);
            if ((targetIn == (-1))) {
              throw new Exception(((("Tried to Goto an unexisting label: " + index) + " ") + label));
            }
            this.addMoveToArrays((index).intValue(), targetIn);
          }
        }
      }
      for (int i_1 = (this.commandArray.size() - 1); (i_1 >= fin); i_1--) {
        {
          this.commandArray.remove(i_1);
          this.midLangArray.remove(i_1);
        }
      }
      StringBuilder builder = new StringBuilder();
      StringBuilder uglyBuilder = new StringBuilder();
      StringBuilder intBuilder = new StringBuilder();
      ExclusiveRange _doubleDotLessThan_1 = new ExclusiveRange(0, fin, true);
      for (final Integer i_1 : _doubleDotLessThan_1) {
        {
          String _get_1 = this.commandArray.get((i_1).intValue());
          builder.append(_get_1);
          String _get_2 = this.commandArray.get((i_1).intValue());
          String _goodSpaces = Utils.goodSpaces(_get_2, this.projectedSize);
          builder.append(_goodSpaces);
          builder.append((";" + i_1));
          String _goodSpaces_1 = Utils.goodSpaces(("" + i_1), 10);
          builder.append(_goodSpaces_1);
          String _get_3 = this.midLangArray.get((i_1).intValue());
          builder.append(_get_3);
          builder.append(OneSharpExpressiveGenerator.SEP);
          String _get_4 = this.commandArray.get((i_1).intValue());
          uglyBuilder.append(_get_4);
          String _get_5 = this.midLangArray.get((i_1).intValue());
          String _plus_1 = (_get_5 + OneSharpExpressiveGenerator.SEP);
          intBuilder.append(_plus_1);
        }
      }
      String _string = uglyBuilder.toString();
      fsa.generateFile((filename + ".os"), _string);
      String _string_1 = builder.toString();
      fsa.generateFile((filename + "_pretty.os"), _string_1);
      String _string_2 = intBuilder.toString();
      fsa.generateFile((filename + ".osi"), _string_2);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public void set(final ArrayList<String> list, final int pos, final String s) {
    list.remove(pos);
    list.add(pos, s);
  }
  
  protected void _calculateSize(final Write cmd) {
    int _projectedSize = this.projectedSize;
    this.projectedSize = (_projectedSize + 15);
  }
  
  protected void _calculateSize(final Goto cmd) {
    this.projectedSize++;
  }
  
  protected void _calculateSize(final Call cmd) {
    FunctionDeclaration _function = cmd.getFunction();
    String _name = _function.getName();
    Integer _get = this.functionLength.get(_name);
    boolean _notEquals = (!Objects.equal(_get, null));
    if (_notEquals) {
      int _projectedSize = this.projectedSize;
      FunctionDeclaration _function_1 = cmd.getFunction();
      String _name_1 = _function_1.getName();
      Integer _get_1 = this.functionLength.get(_name_1);
      this.projectedSize = (_projectedSize + (_get_1).intValue());
      return;
    }
    int oldVal = this.projectedSize;
    FunctionDeclaration _function_2 = cmd.getFunction();
    CommandBlock _body = _function_2.getBody();
    this.calculateSize(_body);
    FunctionDeclaration _function_3 = cmd.getFunction();
    String _name_2 = _function_3.getName();
    this.functionLength.put(_name_2, Integer.valueOf((this.projectedSize - oldVal)));
  }
  
  protected void _calculateSize(final CommandBlock bloc) {
    EList<Command> _commands = bloc.getCommands();
    final Function1<Command, UnlabeledCommand> _function = (Command c) -> {
      return c.getCommand();
    };
    List<UnlabeledCommand> _map = ListExtensions.<Command, UnlabeledCommand>map(_commands, _function);
    for (final UnlabeledCommand cmd : _map) {
      this.calculateSize(cmd);
    }
  }
  
  protected void _calculateSize(final NormalCase cas) {
    int _projectedSize = this.projectedSize;
    this.projectedSize = (_projectedSize + 8);
    CommandBlock _caseOne = cas.getCaseOne();
    this.calculateSize(_caseOne);
    CommandBlock _caseSharp = cas.getCaseSharp();
    this.calculateSize(_caseSharp);
    CommandBlock _caseEmpty = cas.getCaseEmpty();
    this.calculateSize(_caseEmpty);
  }
  
  /**
   * @param   cmd: The command
   * @param   pos: The position in the commandArray where the command should be written
   * @returns int: The position in the commandArray right after the last instruction in of the command.
   */
  protected int _resolve(final Write cmd, final int pos) {
    ParameterContext _peek = this.parameterContextStack.peek();
    RegisterParam _register = cmd.getRegister();
    final Integer reg = _peek.resolve(_register);
    boolean _equals = Objects.equal(reg, null);
    if (_equals) {
      RegisterParam _register_1 = cmd.getRegister();
      String _string = _register_1.toString();
      this.throwUnresolvedException("WRITE ", _string);
    }
    String ones = Utils.ones((reg).intValue());
    String _ones = ones;
    ones = (_ones + "#");
    int tPos = pos;
    ParameterContext _peek_1 = this.parameterContextStack.peek();
    WordParam _word = cmd.getWord();
    String word = _peek_1.resolve(_word);
    boolean _equals_1 = Objects.equal(word, null);
    if (_equals_1) {
      WordParam _word_1 = cmd.getWord();
      String _string_1 = _word_1.toString();
      this.throwUnresolvedException("WRITE ", _string_1);
    }
    int _length = word.length();
    int _minus = (_length - 1);
    String _substring = word.substring(1, _minus);
    word = _substring;
    char[] _charArray = word.toCharArray();
    for (final char c : _charArray) {
      {
        String thisC = ones;
        String s = ("" + Character.valueOf(c));
        boolean _equals_2 = s.equals("1");
        boolean _not = (!_equals_2);
        if (_not) {
          String _thisC = thisC;
          thisC = (_thisC + "#");
        }
        this.commandArray.set(tPos, thisC);
        this.midLangArray.set(tPos, ((("W " + reg) + " ") + Character.valueOf(c)));
        tPos++;
      }
    }
    return tPos;
  }
  
  protected int _resolve(final Call cmd, final int fpos) {
    try {
      ParameterContext pCtx = new ParameterContext();
      FunctionDeclaration fdec = cmd.getFunction();
      EList<ParamDec> pdecs = fdec.getParams();
      EList<CallParam> pcals = cmd.getParams();
      int _size = pdecs.size();
      int _size_1 = pcals.size();
      boolean _notEquals = (_size != _size_1);
      if (_notEquals) {
        String _name = fdec.getName();
        String _plus = ("Wrong number of params in CALL " + _name);
        throw new Exception(_plus);
      }
      for (int i = 0; (i < pdecs.size()); i++) {
        {
          CallParam calp = pcals.get(i);
          ParamDec decp = pdecs.get(i);
          boolean _matchesType = Utils.matchesType(calp, decp);
          boolean _not = (!_matchesType);
          if (_not) {
            String _name_1 = fdec.getName();
            String _plus_1 = ("Wrong type of param in CALL" + _name_1);
            String _plus_2 = (_plus_1 + " ");
            String _name_2 = decp.getName();
            String _plus_3 = (_plus_2 + _name_2);
            throw new Exception(_plus_3);
          }
          String pVal = ((String) null);
          if ((decp instanceof IntParamDec)) {
            Integer pIval = ((Integer) null);
            ParamDec _param = calp.getParam();
            boolean _notEquals_1 = (!Objects.equal(_param, null));
            if (_notEquals_1) {
              ParameterContext _peek = this.parameterContextStack.peek();
              ParamDec _param_1 = calp.getParam();
              String _resolve = _peek.resolve(_param_1);
              Integer _isInt = Utils.isInt(_resolve);
              pIval = _isInt;
            } else {
              int _intVal = calp.getIntVal();
              pIval = Integer.valueOf(_intVal);
            }
            String _plus_4 = (pIval + "");
            pVal = _plus_4;
          } else {
            ParamDec _param_2 = calp.getParam();
            boolean _notEquals_2 = (!Objects.equal(_param_2, null));
            if (_notEquals_2) {
              ParameterContext _peek_1 = this.parameterContextStack.peek();
              ParamDec _param_3 = calp.getParam();
              String _resolve_1 = _peek_1.resolve(_param_3);
              pVal = _resolve_1;
            } else {
              String _stringVal = calp.getStringVal();
              pVal = _stringVal;
            }
          }
          boolean _equals = Objects.equal(pVal, null);
          if (_equals) {
            String _name_3 = decp.getName();
            String _plus_5 = ("Couldn\'t resolve value for " + _name_3);
            String _plus_6 = (_plus_5 + " in CALL ");
            String _name_4 = fdec.getName();
            String _plus_7 = (_plus_6 + _name_4);
            throw new Exception(_plus_7);
          }
          String _name_5 = decp.getName();
          pCtx.valMap.put(_name_5, (pVal + ""));
        }
      }
      String _name_1 = fdec.getName();
      String _plus_1 = ("Call: " + _name_1);
      InputOutput.<String>println(_plus_1);
      Set<String> _keySet = pCtx.valMap.keySet();
      for (final String pair : _keySet) {
        String _get = pCtx.valMap.get(pair);
        String _plus_2 = ((pair + " ") + _get);
        InputOutput.<String>println(_plus_2);
      }
      this.parameterContextStack.push(pCtx);
      CommandBlock _body = fdec.getBody();
      int end = this.resolveCommandBlock(_body, fpos);
      this.parameterContextStack.pop();
      return end;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  /**
   * def dispatch resolve(LoopCase cmd, int fpos){
   * return 0
   * }
   */
  protected int _resolve(final Goto cmd, final int fpos) {
    int pos = fpos;
    Command _label = cmd.getLabel();
    String _name = _label.getName();
    this.commandArray.set(pos, _name);
    this.currentLabelContext.gotosToSolve.add(Integer.valueOf(pos));
    return (pos + 1);
  }
  
  protected int _resolve(final NormalCase cmd, final int fpos) {
    int pos = fpos;
    ParameterContext _peek = this.parameterContextStack.peek();
    RegisterParam _register = cmd.getRegister();
    Integer reg = _peek.resolve(_register);
    boolean _equals = Objects.equal(reg, null);
    if (_equals) {
      RegisterParam _register_1 = cmd.getRegister();
      String _string = _register_1.toString();
      this.throwUnresolvedException("CASES ", _string);
    }
    String _ones = Utils.ones((reg).intValue());
    String _sharps = Utils.sharps(5);
    String caseInst = (_ones + _sharps);
    this.commandArray.set(pos, caseInst);
    this.midLangArray.set(pos, ("C " + reg));
    pos++;
    ArrayList<Integer> ends = CollectionLiterals.<Integer>newArrayList();
    CommandBlock _caseEmpty = cmd.getCaseEmpty();
    int _resolveCommandBlock = this.resolveCommandBlock(_caseEmpty, (fpos + 4));
    pos = _resolveCommandBlock;
    ends.add(Integer.valueOf(pos));
    pos++;
    this.addMoveToArrays((fpos + 1), (fpos + 4));
    this.addMoveToArrays((fpos + 2), pos);
    CommandBlock _caseOne = cmd.getCaseOne();
    int _resolveCommandBlock_1 = this.resolveCommandBlock(_caseOne, pos);
    pos = _resolveCommandBlock_1;
    ends.add(Integer.valueOf(pos));
    pos++;
    this.addMoveToArrays((fpos + 3), pos);
    CommandBlock _caseSharp = cmd.getCaseSharp();
    int _resolveCommandBlock_2 = this.resolveCommandBlock(_caseSharp, pos);
    pos = _resolveCommandBlock_2;
    ends.add(Integer.valueOf(pos));
    pos++;
    for (final Integer end : ends) {
      this.addMoveToArrays((end).intValue(), pos);
    }
    return pos;
  }
  
  public int resolveCommand(final Command cmd, final int fpos) {
    int pos = fpos;
    String _name = cmd.getName();
    boolean _notEquals = (!Objects.equal(_name, null));
    if (_notEquals) {
      String _name_1 = cmd.getName();
      this.currentLabelContext.labelMap.put(_name_1, Integer.valueOf(pos));
    }
    UnlabeledCommand _command = cmd.getCommand();
    int res = this.resolve(_command, pos);
    return res;
  }
  
  public int resolveCommandBlock(final CommandBlock bloc, final int fpos) {
    int pos = fpos;
    EList<Command> commands = bloc.getCommands();
    LabelContext lbc = new LabelContext(bloc, pos, this.currentLabelContext);
    this.currentLabelContext = lbc;
    this.labelContexts.put(Integer.valueOf(pos), this.currentLabelContext);
    for (final Command cmd : commands) {
      int _resolveCommand = this.resolveCommand(cmd, pos);
      pos = _resolveCommand;
    }
    this.currentLabelContext = this.currentLabelContext.parent;
    return pos;
  }
  
  private void throwUnresolvedException(final String f, final String v) {
    try {
      throw new Exception(((("Couldn\'t resolve value of parameter " + v) + " in command ") + f));
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  private void addMoveToArrays(final int source, final int dest) {
    String _oneSharpSourceToDes = Utils.oneSharpSourceToDes(source, dest);
    this.commandArray.set(source, _oneSharpSourceToDes);
    this.midLangArray.set(source, ("M " + Integer.valueOf((dest - source))));
  }
  
  public void calculateSize(final EObject cmd) {
    if (cmd instanceof Call) {
      _calculateSize((Call)cmd);
      return;
    } else if (cmd instanceof Goto) {
      _calculateSize((Goto)cmd);
      return;
    } else if (cmd instanceof NormalCase) {
      _calculateSize((NormalCase)cmd);
      return;
    } else if (cmd instanceof Write) {
      _calculateSize((Write)cmd);
      return;
    } else if (cmd instanceof CommandBlock) {
      _calculateSize((CommandBlock)cmd);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(cmd).toString());
    }
  }
  
  public int resolve(final UnlabeledCommand cmd, final int fpos) {
    if (cmd instanceof Call) {
      return _resolve((Call)cmd, fpos);
    } else if (cmd instanceof Goto) {
      return _resolve((Goto)cmd, fpos);
    } else if (cmd instanceof NormalCase) {
      return _resolve((NormalCase)cmd, fpos);
    } else if (cmd instanceof Write) {
      return _resolve((Write)cmd, fpos);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(cmd, fpos).toString());
    }
  }
}
