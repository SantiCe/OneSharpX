/**
 * generated by Xtext 2.9.0
 */
package ceronsantiago.scoping;

import ceronsantiago.oneSharpExpressive.Call;
import ceronsantiago.oneSharpExpressive.Command;
import ceronsantiago.oneSharpExpressive.CommandBlock;
import ceronsantiago.oneSharpExpressive.FunctionDeclaration;
import ceronsantiago.oneSharpExpressive.Goto;
import ceronsantiago.oneSharpExpressive.IntParamDec;
import ceronsantiago.oneSharpExpressive.NormalCase;
import ceronsantiago.oneSharpExpressive.ParamDec;
import ceronsantiago.oneSharpExpressive.StringParamDec;
import ceronsantiago.oneSharpExpressive.Write;
import ceronsantiago.utils.Utils;
import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom scoping description.
 * 
 * See
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class OneSharpExpressiveScopeProvider extends AbstractDeclarativeScopeProvider {
  /**
   * Scopes the label reference to some command within the CommandBlock that the Goto command belongs to.
   */
  public IScope scope_Goto_label(final Goto command, final EReference eRef) {
    IScope _xblockexpression = null;
    {
      EObject container = command.eContainer();
      ArrayList<Command> coms = new ArrayList<Command>();
      while ((!Objects.equal(container, null))) {
        {
          if ((container instanceof CommandBlock)) {
            EList<Command> _commands = ((CommandBlock) container).getCommands();
            for (final Command cmd : _commands) {
              coms.add(cmd);
            }
          }
          EObject _eContainer = container.eContainer();
          container = _eContainer;
        }
      }
      _xblockexpression = Scopes.scopeFor(coms);
    }
    return _xblockexpression;
  }
  
  /**
   * Scopes unknown parameter usage in function calls.
   */
  public IScope scope_Call_params(final Call command, final EReference eRef) {
    IScope _xblockexpression = null;
    {
      ArrayList<ParamDec> _arrayList = new ArrayList<ParamDec>();
      EList<ParamDec> scope = ((EList<ParamDec>) _arrayList);
      FunctionDeclaration container = Utils.getFunctionDeclaration(command);
      boolean _notEquals = (!Objects.equal(container, null));
      if (_notEquals) {
        FunctionDeclaration fdec = ((FunctionDeclaration) container);
        EList<ParamDec> _params = fdec.getParams();
        scope = _params;
      }
      _xblockexpression = Scopes.scopeFor(scope);
    }
    return _xblockexpression;
  }
  
  /**
   * Generic: Scopes unknown parameter usage that should use IntParams only.
   */
  public IScope scope_Command_intparam(final EObject command, final EReference eRef) {
    IScope _xblockexpression = null;
    {
      ArrayList<IntParamDec> _arrayList = new ArrayList<IntParamDec>();
      List<IntParamDec> scope = ((List<IntParamDec>) _arrayList);
      FunctionDeclaration container = Utils.getFunctionDeclaration(command);
      boolean _notEquals = (!Objects.equal(container, null));
      if (_notEquals) {
        FunctionDeclaration fdec = ((FunctionDeclaration) container);
        EList<ParamDec> _params = fdec.getParams();
        final Function1<ParamDec, Boolean> _function = (ParamDec param) -> {
          return Boolean.valueOf((param instanceof IntParamDec));
        };
        Iterable<ParamDec> _filter = IterableExtensions.<ParamDec>filter(_params, _function);
        final Function1<ParamDec, IntParamDec> _function_1 = (ParamDec param) -> {
          return ((IntParamDec) param);
        };
        Iterable<IntParamDec> _map = IterableExtensions.<ParamDec, IntParamDec>map(_filter, _function_1);
        List<IntParamDec> _list = IterableExtensions.<IntParamDec>toList(_map);
        scope = _list;
      }
      _xblockexpression = Scopes.scopeFor(scope);
    }
    return _xblockexpression;
  }
  
  /**
   * Use method above to restrict register usage in Write and Case calls.
   */
  public IScope scope_Write_register(final Write command, final EReference eRef) {
    return this.scope_Command_intparam(command, eRef);
  }
  
  public IScope scope_NormalCase_register(final NormalCase command, final EReference eRef) {
    return this.scope_Command_intparam(command, eRef);
  }
  
  /**
   * Scope for StringParam only. Since this only is needed in the Write command, don't write a generic.
   */
  public IScope scope_Write_word(final Write command, final EReference eRef) {
    IScope _xblockexpression = null;
    {
      ArrayList<StringParamDec> _arrayList = new ArrayList<StringParamDec>();
      List<StringParamDec> scope = ((List<StringParamDec>) _arrayList);
      FunctionDeclaration container = Utils.getFunctionDeclaration(command);
      boolean _notEquals = (!Objects.equal(container, null));
      if (_notEquals) {
        FunctionDeclaration fdec = ((FunctionDeclaration) container);
        EList<ParamDec> _params = fdec.getParams();
        final Function1<ParamDec, Boolean> _function = (ParamDec param) -> {
          return Boolean.valueOf((param instanceof StringParamDec));
        };
        Iterable<ParamDec> _filter = IterableExtensions.<ParamDec>filter(_params, _function);
        final Function1<ParamDec, StringParamDec> _function_1 = (ParamDec param) -> {
          return ((StringParamDec) param);
        };
        Iterable<StringParamDec> _map = IterableExtensions.<ParamDec, StringParamDec>map(_filter, _function_1);
        List<StringParamDec> _list = IterableExtensions.<StringParamDec>toList(_map);
        scope = _list;
      }
      _xblockexpression = Scopes.scopeFor(scope);
    }
    return _xblockexpression;
  }
}
