/*
 * generated by Xtext 2.9.0
 */
package ceronsantiago.scoping

import ceronsantiago.oneSharpExpressive.Call
import ceronsantiago.oneSharpExpressive.CallParam
import ceronsantiago.oneSharpExpressive.Command
import ceronsantiago.oneSharpExpressive.CommandBlock
import ceronsantiago.oneSharpExpressive.FunctionDeclaration
import ceronsantiago.oneSharpExpressive.Goto
import ceronsantiago.oneSharpExpressive.IntParamDec
import ceronsantiago.oneSharpExpressive.NormalCase
import ceronsantiago.oneSharpExpressive.ParamDec
import ceronsantiago.oneSharpExpressive.StringParamDec
import ceronsantiago.oneSharpExpressive.Write
import ceronsantiago.utils.Utils
import java.util.ArrayList
import java.util.List
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider

/**
 * This class contains custom scoping description.
 * 
 * See 	
 * on how and when to use it.
 */
class OneSharpExpressiveScopeProvider extends AbstractDeclarativeScopeProvider {
	/*
	 * Scopes the label reference to some command within the CommandBlock that the Goto command belongs to. 
	 */
	public def IScope scope_Goto_label(Goto command, EReference eRef){
		//Find the command blocks (probably nested) that the command belongs to. This is the scope for the labels that
		//	this Goto command can reference.
		var container = command.eContainer
		var coms = new ArrayList<Command>()
		while(container != null){
			if(container instanceof CommandBlock){
				for(cmd:(container as CommandBlock).commands)
				{
					coms.add(cmd)
				}
			}
			container = container.eContainer
		}
		Scopes::scopeFor(coms)
	}
	
	/*
	 * Scopes unknown parameter usage in function calls.
	 */
	 public def IScope scope_Call_params(Call command, EReference eRef){
	 	//Try to find the containing function. If it doesn't exist then this command was called in the main body and now
	 	//named parameters are allowed.
	 	var scope = (new ArrayList<ParamDec>() as EList<ParamDec>)
	 	var container = Utils.getFunctionDeclaration(command)
	 	if(container != null){
	 		var fdec = container as FunctionDeclaration
	 		scope = fdec.params
	 	}
	 	Scopes::scopeFor(scope)
	 }
	 
	 /*
	  * Generic: Scopes unknown parameter usage that should use IntParams only.
	  */
	  public def IScope scope_Command_intparam(EObject command, EReference eRef){
	  	var scope = (new ArrayList<IntParamDec>() as List<IntParamDec>)
	 	var container = Utils.getFunctionDeclaration(command)
	 	if(container != null){
	 		var fdec = container as FunctionDeclaration
	 		scope = fdec.params.filter[param|param instanceof IntParamDec].map[param|param as IntParamDec].toList
	 	}
	 	Scopes::scopeFor(scope)
	  }
	  /*
	   * Use method above to restrict register usage in Write and Case calls.
	   */
	  public def IScope scope_Write_register(Write command, EReference eRef){
	  	scope_Command_intparam(command,eRef)
	  }
	  
	  public def IScope scope_NormalCase_register(NormalCase command, EReference eRef){
	  	scope_Command_intparam(command,eRef)
	  }
	  
	  /*
	   * Scope for StringParam only. Since this only is needed in the Write command, don't write a generic.
	   */
	  public def IScope scope_Write_word(Write command, EReference eRef){
	  	var scope = (new ArrayList<StringParamDec>() as List<StringParamDec>)
	 	var container = Utils.getFunctionDeclaration(command)
	 	if(container != null){
	 		var fdec = container as FunctionDeclaration
	 		scope = fdec.params.filter[param|param instanceof StringParamDec].map[param|param as StringParamDec].toList
	 	}
	 	Scopes::scopeFor(scope)
	  }
	  
	  public def IScope scope_CallParam_param(CallParam param, EReerence eRef){
	  	
	  }
}
