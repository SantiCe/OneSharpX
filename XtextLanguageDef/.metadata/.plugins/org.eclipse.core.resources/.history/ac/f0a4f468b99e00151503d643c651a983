/**
 * generated by Xtext 2.9.0
 */
package ceronsantiago.generator;

import ceronsantiago.oneSharpExpressive.Call;
import ceronsantiago.oneSharpExpressive.Command;
import ceronsantiago.oneSharpExpressive.CommandBlock;
import ceronsantiago.oneSharpExpressive.Goto;
import ceronsantiago.oneSharpExpressive.NormalCase;
import ceronsantiago.oneSharpExpressive.Program;
import ceronsantiago.oneSharpExpressive.RegisterParam;
import ceronsantiago.oneSharpExpressive.UnlabeledCommand;
import ceronsantiago.oneSharpExpressive.WordParam;
import ceronsantiago.oneSharpExpressive.Write;
import ceronsantiago.utils.LabelContainer;
import ceronsantiago.utils.Utils;
import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * Generates code from your model files on save.
 */
@SuppressWarnings("all")
public class OneSharpExpressiveGenerator extends AbstractGenerator {
  private final static String SEP = "\n";
  
  private final static String TAB = "\t";
  
  private LabelContainer currLabelContainer;
  
  private HashMap<Integer, LabelContainer> labelContainers;
  
  private int projectedSize = 0;
  
  private ArrayList<String> commandArray;
  
  private ArrayList<String> sanityCommandArray;
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    try {
      this.projectedSize = 0;
      EList<EObject> _contents = resource.getContents();
      EObject _get = _contents.get(0);
      final Program program = ((Program) _get);
      CommandBlock _body = program.getBody();
      EList<Command> _commands = _body.getCommands();
      for (final Command cmd : _commands) {
        UnlabeledCommand _command = cmd.getCommand();
        this.calculateSize(_command);
      }
      ArrayList<String> _arrayList = new ArrayList<String>();
      this.commandArray = _arrayList;
      ArrayList<String> _newArrayList = CollectionLiterals.<String>newArrayList();
      this.sanityCommandArray = _newArrayList;
      int _projectedSize = this.projectedSize;
      this.projectedSize = (_projectedSize + 10);
      ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, this.projectedSize, true);
      for (final Integer i : _doubleDotLessThan) {
        {
          this.commandArray.add("");
          this.sanityCommandArray.add("");
        }
      }
      HashMap<Integer, LabelContainer> _hashMap = new HashMap<Integer, LabelContainer>();
      this.labelContainers = _hashMap;
      this.currLabelContainer = null;
      CommandBlock _body_1 = program.getBody();
      int fin = this.resolveCommandBlock(_body_1, 0);
      final Function1<String, Integer> _function = (String s) -> {
        return Integer.valueOf(s.length());
      };
      String _maxBy = IterableExtensions.<String, Integer>maxBy(this.commandArray, _function);
      int _length = _maxBy.length();
      int _max = Math.max(fin, _length);
      int _plus = (_max + 5);
      this.projectedSize = _plus;
      Collection<LabelContainer> _values = this.labelContainers.values();
      for (final LabelContainer container : _values) {
        for (final Integer index : container.gotosToSolve) {
          {
            String label = this.commandArray.get((index).intValue());
            int targetIn = container.resolve(label);
            InputOutput.<String>println(((("Need to solve goto in " + index) + " and found it in ") + Integer.valueOf(targetIn)));
            if ((targetIn == (-1))) {
              throw new Exception(((("Tried to Goto an unexisting label: " + index) + " ") + label));
            }
            String _oneSharpSourceToDes = Utils.oneSharpSourceToDes((index).intValue(), targetIn);
            this.commandArray.set((index).intValue(), _oneSharpSourceToDes);
          }
        }
      }
      StringBuilder builder = new StringBuilder();
      StringBuilder sanityBuilder = new StringBuilder();
      ExclusiveRange _doubleDotLessThan_1 = new ExclusiveRange(0, fin, true);
      for (final Integer i_1 : _doubleDotLessThan_1) {
        {
          String _get_1 = this.commandArray.get((i_1).intValue());
          builder.append(_get_1);
          String _get_2 = this.commandArray.get((i_1).intValue());
          String _goodSpaces = Utils.goodSpaces(_get_2, this.projectedSize);
          builder.append(_goodSpaces);
          builder.append((";" + i_1));
          builder.append(OneSharpExpressiveGenerator.SEP);
          String _get_3 = this.sanityCommandArray.get((i_1).intValue());
          sanityBuilder.append(_get_3);
          sanityBuilder.append(OneSharpExpressiveGenerator.SEP);
        }
      }
      String _string = builder.toString();
      fsa.generateFile("TestFile.os", _string);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public void set(final ArrayList<String> list, final int pos, final String s) {
    list.remove(pos);
    list.add(pos, s);
  }
  
  protected Integer _calculateSize(final Write cmd) {
    int _projectedSize = this.projectedSize;
    WordParam _word = cmd.getWord();
    String _value = _word.getValue();
    int _length = _value.length();
    return Integer.valueOf(this.projectedSize = (_projectedSize + _length));
  }
  
  protected Integer _calculateSize(final Goto cmd) {
    return Integer.valueOf(this.projectedSize++);
  }
  
  protected Integer _calculateSize(final Call cmd) {
    return Integer.valueOf(this.projectedSize++);
  }
  
  protected Integer _calculateSize(final NormalCase cas) {
    int _projectedSize = this.projectedSize;
    this.projectedSize = (_projectedSize + 8);
    CommandBlock _caseOne = cas.getCaseOne();
    EList<Command> _commands = _caseOne.getCommands();
    for (final Command cmd : _commands) {
      UnlabeledCommand _command = cmd.getCommand();
      this.calculateSize(_command);
    }
    CommandBlock _caseSharp = cas.getCaseSharp();
    EList<Command> _commands_1 = _caseSharp.getCommands();
    for (final Command cmd_1 : _commands_1) {
      UnlabeledCommand _command_1 = cmd_1.getCommand();
      this.calculateSize(_command_1);
    }
    CommandBlock _caseEmpty = cas.getCaseEmpty();
    EList<Command> _commands_2 = _caseEmpty.getCommands();
    for (final Command cmd_2 : _commands_2) {
      UnlabeledCommand _command_2 = cmd_2.getCommand();
      this.calculateSize(_command_2);
    }
    return null;
  }
  
  /**
   * @param   cmd: The command
   * @param   pos: The position in the commandArray where the command should be written
   * @returns int: The position in the commandArray right after the last instruction in of the command.
   */
  protected int _resolve(final Write cmd, final int pos) {
    RegisterParam _register = cmd.getRegister();
    final int reg = _register.getValue();
    String ones = Utils.ones(reg);
    String _ones = ones;
    ones = (_ones + "#");
    int tPos = pos;
    WordParam _word = cmd.getWord();
    WordParam _word_1 = cmd.getWord();
    String _value = _word_1.getValue();
    WordParam _word_2 = cmd.getWord();
    String _value_1 = _word_2.getValue();
    int _length = _value_1.length();
    int _minus = (_length - 1);
    String _substring = _value.substring(1, _minus);
    _word.setValue(_substring);
    WordParam _word_3 = cmd.getWord();
    String _value_2 = _word_3.getValue();
    String _string = _value_2.toString();
    char[] _charArray = _string.toCharArray();
    for (final char c : _charArray) {
      {
        String thisC = ones;
        String s = ("" + Character.valueOf(c));
        String _plus = (Character.valueOf(c) + " ");
        boolean _equals = s.equals("1");
        String _plus_1 = (_plus + Boolean.valueOf(_equals));
        String _plus_2 = (_plus_1 + " ");
        boolean _equals_1 = s.equals("#");
        String _plus_3 = (_plus_2 + Boolean.valueOf(_equals_1));
        InputOutput.<String>println(_plus_3);
        boolean _notEquals = (!Objects.equal(Character.valueOf(c), "1"));
        if (_notEquals) {
          String _thisC = thisC;
          thisC = (_thisC + "#");
        }
        this.commandArray.set(tPos, thisC);
        this.sanityCommandArray.set(pos, ((("write " + Integer.valueOf(reg)) + " ") + Character.valueOf(c)));
        tPos++;
      }
    }
    return tPos;
  }
  
  protected int _resolve(final Call cmd, final int fpos) {
    return 0;
  }
  
  /**
   * def dispatch resolve(LoopCase cmd, int fpos){
   * return 0
   * }
   */
  protected int _resolve(final Goto cmd, final int fpos) {
    int pos = fpos;
    Command _label = cmd.getLabel();
    String _name = _label.getName();
    this.commandArray.set(pos, _name);
    Command _label_1 = cmd.getLabel();
    String _name_1 = _label_1.getName();
    String _plus = ("Adds goto label " + _name_1);
    String _plus_1 = (_plus + " ");
    String _plus_2 = (_plus_1 + Integer.valueOf(pos));
    InputOutput.<String>println(_plus_2);
    this.currLabelContainer.gotosToSolve.add(Integer.valueOf(pos));
    return (pos + 1);
  }
  
  protected int _resolve(final NormalCase cmd, final int fpos) {
    int pos = fpos;
    RegisterParam _register = cmd.getRegister();
    int reg = _register.getValue();
    String _ones = Utils.ones(reg);
    String _sharps = Utils.sharps(5);
    String caseInst = (_ones + _sharps);
    this.commandArray.set(pos, caseInst);
    pos++;
    CommandBlock _caseOne = cmd.getCaseOne();
    int _resolveCommandBlock = this.resolveCommandBlock(_caseOne, (fpos + 5));
    pos = _resolveCommandBlock;
    String _oneSharpSourceToDes = Utils.oneSharpSourceToDes(pos, (fpos + 4));
    this.commandArray.set(pos, _oneSharpSourceToDes);
    pos++;
    String _oneSharpSourceToDes_1 = Utils.oneSharpSourceToDes((fpos + 1), (fpos + 5));
    this.commandArray.set((fpos + 1), _oneSharpSourceToDes_1);
    String _oneSharpSourceToDes_2 = Utils.oneSharpSourceToDes((fpos + 2), pos);
    this.commandArray.set((fpos + 2), _oneSharpSourceToDes_2);
    CommandBlock _caseSharp = cmd.getCaseSharp();
    int _resolveCommandBlock_1 = this.resolveCommandBlock(_caseSharp, pos);
    pos = _resolveCommandBlock_1;
    String _oneSharpSourceToDes_3 = Utils.oneSharpSourceToDes(pos, (fpos + 4));
    this.commandArray.set(pos, _oneSharpSourceToDes_3);
    pos++;
    String _oneSharpSourceToDes_4 = Utils.oneSharpSourceToDes((fpos + 3), pos);
    this.commandArray.set((fpos + 3), _oneSharpSourceToDes_4);
    CommandBlock _caseEmpty = cmd.getCaseEmpty();
    int _resolveCommandBlock_2 = this.resolveCommandBlock(_caseEmpty, pos);
    pos = _resolveCommandBlock_2;
    String _oneSharpSourceToDes_5 = Utils.oneSharpSourceToDes(pos, (fpos + 4));
    this.commandArray.set(pos, _oneSharpSourceToDes_5);
    pos++;
    String _oneSharpSourceToDes_6 = Utils.oneSharpSourceToDes((fpos + 4), pos);
    this.commandArray.set((fpos + 4), _oneSharpSourceToDes_6);
    return pos;
  }
  
  public int resolveCommand(final Command cmd, final int fpos) {
    int pos = fpos;
    String _name = cmd.getName();
    boolean _notEquals = (!Objects.equal(_name, null));
    if (_notEquals) {
      String _name_1 = cmd.getName();
      this.currLabelContainer.labelMap.put(_name_1, Integer.valueOf(pos));
      String _name_2 = cmd.getName();
      String _plus = ("Putting label " + _name_2);
      String _plus_1 = (_plus + " in ");
      String _plus_2 = (_plus_1 + Integer.valueOf(pos));
      InputOutput.<String>println(_plus_2);
    }
    UnlabeledCommand _command = cmd.getCommand();
    int res = this.resolve(_command, pos);
    return res;
  }
  
  public int resolveCommandBlock(final CommandBlock bloc, final int fpos) {
    int pos = fpos;
    EList<Command> commands = bloc.getCommands();
    LabelContainer lbc = new LabelContainer(bloc, pos, this.currLabelContainer);
    this.currLabelContainer = lbc;
    this.labelContainers.put(Integer.valueOf(pos), this.currLabelContainer);
    for (final Command cmd : commands) {
      int _resolveCommand = this.resolveCommand(cmd, pos);
      pos = _resolveCommand;
    }
    return pos;
  }
  
  public Integer calculateSize(final UnlabeledCommand cmd) {
    if (cmd instanceof Call) {
      return _calculateSize((Call)cmd);
    } else if (cmd instanceof Goto) {
      return _calculateSize((Goto)cmd);
    } else if (cmd instanceof NormalCase) {
      return _calculateSize((NormalCase)cmd);
    } else if (cmd instanceof Write) {
      return _calculateSize((Write)cmd);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(cmd).toString());
    }
  }
  
  public int resolve(final UnlabeledCommand cmd, final int fpos) {
    if (cmd instanceof Call) {
      return _resolve((Call)cmd, fpos);
    } else if (cmd instanceof Goto) {
      return _resolve((Goto)cmd, fpos);
    } else if (cmd instanceof NormalCase) {
      return _resolve((NormalCase)cmd, fpos);
    } else if (cmd instanceof Write) {
      return _resolve((Write)cmd, fpos);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(cmd, fpos).toString());
    }
  }
}
