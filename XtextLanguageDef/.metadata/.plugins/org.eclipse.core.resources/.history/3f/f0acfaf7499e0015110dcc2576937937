/**
 * generated by Xtext 2.9.0
 */
package ceronsantiago.generator;

import ceronsantiago.oneSharpExpressive.Call;
import ceronsantiago.oneSharpExpressive.Command;
import ceronsantiago.oneSharpExpressive.CommandBlock;
import ceronsantiago.oneSharpExpressive.Goto;
import ceronsantiago.oneSharpExpressive.IdOrInt;
import ceronsantiago.oneSharpExpressive.IdOrString;
import ceronsantiago.oneSharpExpressive.LoopCase;
import ceronsantiago.oneSharpExpressive.NormalCase;
import ceronsantiago.oneSharpExpressive.Program;
import ceronsantiago.oneSharpExpressive.UnlabeledCommand;
import ceronsantiago.oneSharpExpressive.Write;
import ceronsantiago.onesharpx.LabelContainer;
import ceronsantiago.onesharpx.Utils;
import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;

/**
 * Generates code from your model files on save.
 */
@SuppressWarnings("all")
public class OneSharpExpressiveGenerator extends AbstractGenerator {
  private final static String SEP = "\n";
  
  private LabelContainer currLabelContainer;
  
  private HashMap<Integer, LabelContainer> labelContainers;
  
  private int projectedSize = 0;
  
  private ArrayList<String> commandArray;
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    this.projectedSize = 0;
    EList<EObject> _contents = resource.getContents();
    EObject _get = _contents.get(0);
    final Program program = ((Program) _get);
    CommandBlock _body = program.getBody();
    EList<Command> _commands = _body.getCommands();
    for (final Command cmd : _commands) {
      UnlabeledCommand _command = cmd.getCommand();
      this.calculateSize(_command);
    }
    ArrayList<String> _arrayList = new ArrayList<String>();
    this.commandArray = _arrayList;
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, (this.projectedSize * 2), true);
    for (final Integer i : _doubleDotLessThan) {
      this.commandArray.add("");
    }
    HashMap<Integer, LabelContainer> _hashMap = new HashMap<Integer, LabelContainer>();
    this.labelContainers = _hashMap;
  }
  
  public void set(final ArrayList<String> list, final int pos, final String s) {
    list.remove(pos);
    list.add(pos, s);
  }
  
  protected Integer _calculateSize(final Write cmd) {
    return Integer.valueOf(this.projectedSize++);
  }
  
  protected Integer _calculateSize(final Goto cmd) {
    return Integer.valueOf(this.projectedSize++);
  }
  
  protected Integer _calculateSize(final Call cmd) {
    return Integer.valueOf(this.projectedSize++);
  }
  
  protected Integer _calculateSize(final NormalCase cas) {
    int _projectedSize = this.projectedSize;
    this.projectedSize = (_projectedSize + 8);
    CommandBlock _caseOne = cas.getCaseOne();
    EList<Command> _commands = _caseOne.getCommands();
    for (final Command cmd : _commands) {
      UnlabeledCommand _command = cmd.getCommand();
      this.calculateSize(_command);
    }
    CommandBlock _caseSharp = cas.getCaseSharp();
    EList<Command> _commands_1 = _caseSharp.getCommands();
    for (final Command cmd_1 : _commands_1) {
      UnlabeledCommand _command_1 = cmd_1.getCommand();
      this.calculateSize(_command_1);
    }
    CommandBlock _caseEmpty = cas.getCaseEmpty();
    EList<Command> _commands_2 = _caseEmpty.getCommands();
    for (final Command cmd_2 : _commands_2) {
      UnlabeledCommand _command_2 = cmd_2.getCommand();
      this.calculateSize(_command_2);
    }
    return null;
  }
  
  protected Integer _calculateSize(final LoopCase cas) {
    return null;
  }
  
  /**
   * @param   cmd: The command
   * @param   pos: The position in the commandArray where the command should be written
   * @returns int: The position in the commandArray right after the last instruction in of the command.
   */
  protected int _resolve(final Write cmd, final int pos) {
    IdOrInt _register = cmd.getRegister();
    final int reg = _register.getValue();
    String ones = Utils.ones(reg);
    String _ones = ones;
    ones = (_ones + "#");
    int tPos = pos;
    IdOrString _word = cmd.getWord();
    String _value = _word.getValue();
    String _string = _value.toString();
    char[] _charArray = _string.toCharArray();
    for (final char c : _charArray) {
      {
        String thisC = ones;
        boolean _equals = Objects.equal(Character.valueOf(c), "#");
        if (_equals) {
          String _thisC = thisC;
          thisC = (_thisC + "#");
        }
        this.commandArray.set(pos, thisC);
        tPos++;
      }
    }
    return tPos;
  }
  
  protected int _resolve(final Call cmd, final int fpos) {
    return 0;
  }
  
  protected int _resolve(final LoopCase cmd, final int fpos) {
    return 0;
  }
  
  protected int _resolve(final Goto cmd, final int fpos) {
    int pos = fpos;
    Command _label = cmd.getLabel();
    String _name = _label.getName();
    this.commandArray.set(pos, _name);
    this.currLabelContainer.gotosToSolve.add(Integer.valueOf(pos));
    return (pos + 1);
  }
  
  protected int _resolve(final NormalCase cmd, final int fpos) {
    throw new Error("Unresolved compilation problems:"
      + "\nno viable alternative at input \')\'"
      + "\nInvalid number of arguments. The method set(int, E) is not applicable for the arguments (int)");
  }
  
  public int resolveCommand(final Command cmd, final int fpos) {
    int pos = fpos;
    String _name = cmd.getName();
    boolean _notEquals = (!Objects.equal(_name, null));
    if (_notEquals) {
      String _name_1 = cmd.getName();
      this.currLabelContainer.labelMap.put(_name_1, Integer.valueOf(pos));
    }
    UnlabeledCommand _command = cmd.getCommand();
    return this.resolve(_command, pos);
  }
  
  public int resolveCommandBlock(final CommandBlock bloc, final int fpos) {
    int pos = fpos;
    EList<Command> commands = bloc.getCommands();
    LabelContainer lbc = new LabelContainer(bloc, pos, this.currLabelContainer);
    this.currLabelContainer = lbc;
    this.labelContainers.put(Integer.valueOf(pos), this.currLabelContainer);
    for (final Command cmd : commands) {
      int _resolveCommand = this.resolveCommand(cmd, pos);
      pos = _resolveCommand;
    }
    return pos;
  }
  
  public Integer calculateSize(final UnlabeledCommand cmd) {
    if (cmd instanceof Call) {
      return _calculateSize((Call)cmd);
    } else if (cmd instanceof Goto) {
      return _calculateSize((Goto)cmd);
    } else if (cmd instanceof LoopCase) {
      return _calculateSize((LoopCase)cmd);
    } else if (cmd instanceof NormalCase) {
      return _calculateSize((NormalCase)cmd);
    } else if (cmd instanceof Write) {
      return _calculateSize((Write)cmd);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(cmd).toString());
    }
  }
  
  public int resolve(final UnlabeledCommand cmd, final int fpos) {
    if (cmd instanceof Call) {
      return _resolve((Call)cmd, fpos);
    } else if (cmd instanceof Goto) {
      return _resolve((Goto)cmd, fpos);
    } else if (cmd instanceof LoopCase) {
      return _resolve((LoopCase)cmd, fpos);
    } else if (cmd instanceof NormalCase) {
      return _resolve((NormalCase)cmd, fpos);
    } else if (cmd instanceof Write) {
      return _resolve((Write)cmd, fpos);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(cmd, fpos).toString());
    }
  }
}
