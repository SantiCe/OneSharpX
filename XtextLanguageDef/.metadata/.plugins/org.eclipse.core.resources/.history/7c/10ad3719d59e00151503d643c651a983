/*
 * generated by Xtext 2.9.0
 */
package ceronsantiago.generator

import ceronsantiago.oneSharpExpressive.Call
import ceronsantiago.oneSharpExpressive.Command
import ceronsantiago.oneSharpExpressive.CommandBlock
import ceronsantiago.oneSharpExpressive.Goto
import ceronsantiago.oneSharpExpressive.NormalCase
import ceronsantiago.oneSharpExpressive.Program
import ceronsantiago.oneSharpExpressive.Write
import ceronsantiago.utils.LabelContext
import ceronsantiago.utils.ParameterContext
import ceronsantiago.utils.Utils
import java.util.ArrayList
import java.util.HashMap
import java.util.Stack
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import ceronsantiago.oneSharpExpressive.IntParamDec

/**
 * Generates code from your model files on save.		
 */
class OneSharpExpressiveGenerator extends AbstractGenerator {
	static final val SEP = "\n"
	static final val TAB = "\t"
	
	LabelContext currentLabelContext
	HashMap<Integer,LabelContext> labelContexts
	/**
	 * TODO: THIS IS MACHETE, for now lets leave it but it will cause failures.
	 */
	var projectedSize = 0
	private ArrayList<String> commandArray
	private ArrayList<String> midLangArray
	private Stack<ParameterContext> parameterContextStack
	/**
	 * Map that for a function tells how many lines it will take. Implemented to make counting a bit more efficient.
	 */
	private HashMap<String,Integer> functionLength
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		projectedSize = 0
		//Calculate the size
		val program = (resource.contents.get(0) as Program)
		//First, guesstimate how long the program will be. This fills the commandArray with placeholder empty strings
		//which makes implementation of this generator more comfortable, since we now only have to use the set method
		// for everything. 
		functionLength = new HashMap<String,Integer>
		for(cmd:program.body.commands) cmd.command.calculateSize
		commandArray = new ArrayList<String>()
		midLangArray = newArrayList()
		projectedSize+=10
		for(i:0..<projectedSize){
			commandArray.add("")
			midLangArray.add("")	
		}
		//Now resolve recursively
		labelContexts = new HashMap<Integer,LabelContext>
		parameterContextStack = new Stack<ParameterContext>
		currentLabelContext = null
		var fin = resolveCommandBlock(program.body,0)
		projectedSize= Math.max(fin,commandArray.maxBy[s|s.length].length)+5
		//Do unresolved GOTO calls.
		for(container:labelContexts.values){
			for(index:container.gotosToSolve){
				var label = commandArray.get(index)
				var targetIn = container.resolve(label)
				if(targetIn == -1){
					throw new Exception("Tried to Goto an unexisting label: "+index+" "+label)
				}
				addMoveToArrays(index,targetIn)
			}
		}
		//ALL DONE! Write it out to file.
		
		//Clean the arrays of unnecessary stuff. This is specially useful for the @link midLangArray.
		for(var i = commandArray.size-1; i >= fin; i--){
			commandArray.remove(i)
			midLangArray.remove(i)
		}
		
		
		var builder = new StringBuilder
		var sanityBuilder = new StringBuilder
		for(i:0..<fin){
			builder.append(commandArray.get(i))
			builder.append(Utils.goodSpaces(commandArray.get(i),projectedSize));
			builder.append(";"+i)
			builder.append(Utils.goodSpaces(""+i,10))
			builder.append(midLangArray.get(i))
			builder.append(SEP)
			
		}
		fsa.generateFile("TestFile.os",builder.toString)
	}
	
	def set(ArrayList<String> list,int pos,String s){
		list.remove(pos)
		list.add(pos,s)
	}
	//The calculateSize methods are intended to calculate the final size of the 1# program in terms of instructions.
	def dispatch void calculateSize(Write cmd){
		projectedSize+=15
	}
	
	def dispatch void calculateSize(Goto cmd){
		projectedSize++
	}
	
	def dispatch void calculateSize(Call cmd){
		//A function line takes as many lines as the function takes to write out completely.
		if(functionLength.get(cmd.function.name) != null) {
			projectedSize+=functionLength.get(cmd.function.name)
			return
		}
		var oldVal = projectedSize
		cmd.function.body.calculateSize
		functionLength.put(cmd.function.name,projectedSize-oldVal)
	}
	
	def dispatch void calculateSize(CommandBlock bloc){
		for(cmd:bloc.commands.map[c|c.command]) cmd.calculateSize
	}
	
	def dispatch void calculateSize(NormalCase cas){
		//A case takes four lines in the main code, one line to skip to the end and one line per case to skip to the end.
		projectedSize+=8
		cas.caseOne.calculateSize
		cas.caseSharp.calculateSize
		cas.caseEmpty.calculateSize
	}
	
	/*def dispatch calculateSize(LoopCase cas){
		//TODO: Support for loop case.
	}*/
	
	//The resolve methods convert 1#X commands into 1# commands.
	/**
	 * @param   cmd: The command
	 * @param   pos: The position in the commandArray where the command should be written
	 * @returns int: The position in the commandArray right after the last instruction in of the command.  
	 */
	def dispatch resolve(Write cmd, int pos){
		//First build the beginning of the instruction with the ones indicating the register.
		val reg = parameterContextStack.peek().resolve(cmd.register)
		if(reg == null) throwUnresolvedException("WRITE ",cmd.register.toString)
		var ones = Utils.ones(reg)
		ones+="#" 
		var tPos = pos
		var word = parameterContextStack.peek().resolve(cmd.word)
		//Now read the characters to write.
		if(word == null) throwUnresolvedException("WRITE ",cmd.word.toString)	
		word = word.substring(1,word.length-1)
		for(c:word.toCharArray) //TODO: What if this is a variable.
		{
			var thisC = ones
			var s = ""+c
			if(!s.equals("1"))thisC+="#"
			commandArray.set(tPos,thisC)
			midLangArray.set(tPos,"W "+reg+" "+c)
			tPos++
		}
		return tPos
	}
	def dispatch resolve(Call cmd, int fpos){
		//TODO: This can be done much more efficiently.
		var pCtx = new ParameterContext
		var fdec = cmd.function
		var pdecs = fdec.params
		var pcals = cmd.params
		//These checks should not be necessary.
		if(pdecs.size != pcals.size) throw new Exception("Wrong number of params in CALL "+fdec.name)
		//Check all the parameters and make sure we have resolved the values for every one of them. 
		for(var i = 0; i < pdecs.size; i ++){
			var calp = pcals.get(i)
			var decp = pdecs.get(i)
			if(!Utils.matchesType(calp,decp)) throw new Exception("Wrong type of param in CALL"+fdec.name+" "+decp.name)
			var pVal = null as String
			if(decp instanceof IntParamDec){
				var pIval = null as Integer
				//If this is an int param.
				if(calp.param != null){
					//If this is a parameter reference, then the value for this int is contained in this 
					//parameter context.
					pIval = Utils.isInt(parameterContextStack.peek().resolve(decp))
				}
				else{
					//If this is not a parameter reference, it is a straight value
					pIval = calp.intVal
				}
				pVal = pIval+""
			}
			else{
				//If this is a String param
				if(calp.param != null){
					//If this is a parameter reference, then the value for this String is contained in the
					//current parameter context.
					pVal = parameterContextStack.peek().resolve(decp)
				}
				else{
					pVal = calp.stringVal
				}
			}
			if(pVal == null) throw new Exception("Couldn't resolve value for "+decp.name+" in CALL "+fdec.name)
			pCtx.valMap.put(decp.name,pVal+"")
		}
		//Stack the new parameter context and continue:
		parameterContextStack.push(pCtx)
		//Resolve the function
		var end = resolveCommandBlock(fdec.body,fpos)
		//Remove from stack.
		parameterContextStack.pop()
		//Go on with life.
		return end
	}
	
	/*def dispatch resolve(LoopCase cmd, int fpos){
		return 0	
	}*/
	
	def dispatch resolve(Goto cmd, int fpos){
		var pos = fpos
		//Leave a placeholder to be resolved later.
		commandArray.set(pos,cmd.label.name)
		println("Adds goto label "+cmd.label.name+" "+pos)
		currentLabelContext.gotosToSolve.add(pos)
		return (pos+1)
	}
	
	def dispatch resolve(NormalCase cmd, int fpos){
		var pos = fpos //In fpos is the beginning of the cases instruction.
		var reg = parameterContextStack.peek().resolve(cmd.register)
		if(reg == null) throwUnresolvedException("CASES ",cmd.register.toString)
		var caseInst = Utils.ones(reg)+Utils.sharps(5)
		commandArray.set(pos,caseInst); midLangArray.set(pos,"C "+reg); pos++;
		//Resolve first case. Start at position pos+4 to leave room for other cases and the call to continue.
		pos = resolveCommandBlock(cmd.caseEmpty,fpos+5)
		//Tell it to go back at the end of each case. pos now has the end of case 1 implementation.
		addMoveToArrays(pos,fpos+4)
		pos++;
		//And in the cases declaration tell it where it will find the start of the case implementation.
		addMoveToArrays(fpos+1,fpos+5)
		//Do the same for the other cases.
			//Case #
		addMoveToArrays(fpos+2,pos)
		pos = resolveCommandBlock(cmd.caseSharp,pos)
		addMoveToArrays(pos,fpos+4)
		pos++;
			//Case empty
		addMoveToArrays(fpos+3,pos)
		pos = resolveCommandBlock(cmd.caseEmpty,pos)
		addMoveToArrays(pos,fpos+4)
		pos++;
		
		//At the end (fpos+4) it should skip to pos.
		//TODO: We could save this (fpos+4) line by telling in each case implementation directly where to go.
		addMoveToArrays(fpos+4,pos)
		return pos
	}
	
	def int resolveCommand(Command cmd, int fpos){
		var pos = fpos
		//Add label to the label map.
		if(cmd.name != null) 
		{
			currentLabelContext.labelMap.put(cmd.name, pos)
			println("Putting label "+cmd.name+" in "+pos)	
		}
		var res = cmd.command.resolve(pos)
		//println("Resolve command called from "+pos+" result "+res+" with command "+cmd.command.class)
		return res
	}
	def resolveCommandBlock(CommandBlock bloc, int fpos){
		var pos = fpos
		var commands = bloc.commands
		var lbc = new LabelContext(bloc,pos,currentLabelContext)
		currentLabelContext = lbc
		labelContexts.put(pos,currentLabelContext)
		for(cmd:commands){
			pos = cmd.resolveCommand(pos)
		}
		return pos
	}

	def private throwUnresolvedException(String f, String v){
		throw new Exception("Couldn't resolve value of parameter "+v+" in command "+f)
	}	
	
	def private void addMoveToArrays(int source, int dest){
		commandArray.set(source,Utils.oneSharpSourceToDes(source,dest))
		midLangArray.set(source,"M "+(dest-source));
	}
}
